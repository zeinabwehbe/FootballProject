"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePayload = void 0;
const validatePayload = async ({ schemaValidator, payload, propertiesToValidate, }) => {
    const errors = {};
    for (const propertyToValidate of propertiesToValidate) {
        const propertySchema = schemaValidator.schema[propertyToValidate];
        try {
            await propertySchema?.yupSchema.validate(payload[propertyToValidate], {
                ...propertySchema.validateOptions,
                context: {
                    payload,
                    ...propertySchema.validateOptions?.context,
                },
            });
        }
        catch (yupValidationError) {
            errors[propertyToValidate] = buildErrorPayload({
                yupValidationError,
                errorMessages: schemaValidator.errorMessages,
            });
        }
    }
    return Object.keys(errors).length ? errors : null;
};
exports.validatePayload = validatePayload;
const buildErrorPayload = ({ errorMessages, yupValidationError, }) => {
    const yupValidationResultErrors = yupValidationError.inner && yupValidationError.inner.length > 0 ? yupValidationError.inner : [yupValidationError];
    return yupValidationResultErrors.reduce((errorsResult, { path: propertyPath, message: yupErrorMessage }) => {
        if (errorsResult.find(({ propertyPath: accPropertyPath }) => accPropertyPath === propertyPath)) {
            return errorsResult;
        }
        const errorMessage = errorMessages ? errorMessages[yupErrorMessage] : { message: yupErrorMessage };
        return errorsResult.concat({
            ...errorMessage,
            propertyPath,
        });
    }, []);
};
//# sourceMappingURL=schema-validator.js.map